name: Run Bot 24/7

on:
  push:
    branches: [ main, master ]
    paths:
      - '.github/workflows/deploy.yml'
      - 'cmd/**'
      - 'internal/**'
      - 'go.mod'
      - 'go.sum'
      - '.trigger'
  workflow_dispatch:

# Concurrency control: Only one instance should run at a time
# If a new workflow is triggered while one is running, it will wait for the current one to finish
concurrency:
  group: netblocks-bot-24-7
  cancel-in-progress: false  # Don't cancel existing runs, queue new ones instead

permissions:
  contents: write  # Write permission needed to commit .trigger file for auto-restart

jobs:
  run-bot:
    runs-on: ubuntu-latest
    timeout-minutes: 525600  # 1 year (maximum allowed)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        persist-credentials: true
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
      
    - name: Verify secrets
      run: |
        if [ -z "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then
          echo "Error: TELEGRAM_BOT_TOKEN secret not set"
          exit 1
        fi
        if [ -z "${{ secrets.TELEGRAM_CHANNEL }}" ]; then
          echo "Warning: TELEGRAM_CHANNEL secret not set"
        fi
        if [ -z "${{ secrets.CLOUDFLARE_TOKEN }}" ]; then
          echo "Warning: CLOUDFLARE_TOKEN not set - traffic charts will not be available"
        fi
        echo "‚úì Secrets verified"

    - name: Build bot
      run: |
        go build -o netblocks-telegram-bot ./cmd/telegram-bot
        chmod +x netblocks-telegram-bot
        echo "‚úì Bot built successfully"
      
    - name: Start bot in background
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHANNEL: ${{ secrets.TELEGRAM_CHANNEL }}
        CLOUDFLARE_TOKEN: ${{ secrets.CLOUDFLARE_TOKEN }}
      run: |
        nohup ./netblocks-telegram-bot > bot.log 2>&1 &
        BOT_PID=$!
        echo $BOT_PID > bot.pid
        echo "‚úì Bot started with PID: $BOT_PID"
        echo "‚úì Environment variables set"
        
    - name: Wait for initialization
      run: sleep 10
      
    - name: Verify bot is running
      run: |
        if [ -f bot.pid ]; then
          BOT_PID=$(cat bot.pid)
          if kill -0 $BOT_PID 2>/dev/null; then
            echo "‚úì Bot is running with PID: $BOT_PID"
            echo ""
            echo "============================================"
            echo "Full startup logs (showing Cloudflare auth):"
            echo "============================================"
            cat bot.log
            echo ""
            echo "============================================"
            echo "Bot started successfully!"
            echo "Channel: ${{ secrets.TELEGRAM_CHANNEL }}"
            echo "Entering monitoring mode..."
            echo "This workflow will run forever (never complete)"
            echo "============================================"
          else
            echo "‚úó Bot process not found"
            echo ""
            echo "Full logs:"
            cat bot.log
            exit 1
          fi
        else
          echo "‚úó bot.pid file not found"
          exit 1
        fi
    
    - name: Monitor bot forever
      run: |
        BOT_PID=$(cat bot.pid)
        COUNTER=1
        
        echo ""
        echo "ü§ñ NetBlocks Bot is now running 24/7"
        echo "üìä Monitoring Iranian ASNs and DNS servers"
        echo "üì¢ Sending updates to Telegram channel every 10 minutes"
        echo ""
        
        # Print Cloudflare authentication and connection status
        echo "=========================================="
        echo "üîë Cloudflare Radar API Status:"
        echo "=========================================="
        
        # Check if bot log exists
        if [ ! -f bot.log ]; then
          echo "‚è≥ Bot log file not found yet, waiting for initialization..."
          echo "=========================================="
          echo ""
        else
          # Initialize status variables
          TOKEN_RECEIVED=false
          AUTH_METHOD=""
          API_CONNECTED=false
          DATA_AVAILABLE=false
          STATUS_CODE=""
          ERROR_MSG=""
          DATA_POINTS=0
          
          # Check if token was received
          if grep -q "NewTrafficMonitor: token set=true" bot.log 2>/dev/null; then
            TOKEN_RECEIVED=true
            TOKEN_LINE=$(grep "NewTrafficMonitor: token set=true" bot.log | tail -1)
            if echo "$TOKEN_LINE" | grep -q "len="; then
              TOKEN_LEN=$(echo "$TOKEN_LINE" | sed -n 's/.*len=\([0-9]*\).*/\1/p')
            fi
          fi
          
          # Check authentication method
          if grep -q "Using Cloudflare Bearer Token authentication" bot.log 2>/dev/null; then
            AUTH_METHOD="Bearer Token"
            if [ -n "$TOKEN_LEN" ]; then
              AUTH_METHOD="Bearer Token (length: $TOKEN_LEN)"
            fi
          fi
          
          # Check for Cloudflare API responses - capture ANY status code
          if grep -q "Cloudflare API response: Status" bot.log 2>/dev/null; then
            # Get the latest status response
            STATUS_LINE=$(grep "Cloudflare API response: Status" bot.log | tail -1)
            STATUS_CODE_NUM=$(echo "$STATUS_LINE" | sed -n 's/.*Status \([0-9]*\).*/\1/p')
            STATUS_TEXT=$(echo "$STATUS_LINE" | sed -n 's/.*Status [0-9]* \([^(]*\).*/\1/p' | xargs)
            
            if [ "$STATUS_CODE_NUM" = "200" ]; then
              API_CONNECTED=true
              STATUS_CODE="200 OK"
              
              # Check if data was received
              if grep -q "Cloudflare API success - received" bot.log 2>/dev/null; then
                SUCCESS_LINE=$(grep "Cloudflare API success - received" bot.log | tail -1)
                DATA_AVAILABLE=true
                # Extract data points count
                if echo "$SUCCESS_LINE" | grep -q "received [0-9]* data points"; then
                  DATA_POINTS=$(echo "$SUCCESS_LINE" | sed -n 's/.*received \([0-9]*\) data points.*/\1/p')
                fi
              fi
            else
              # Any non-200 status code
              API_CONNECTED=false
              STATUS_CODE="$STATUS_CODE_NUM $STATUS_TEXT"
              
              # Extract error message from Cloudflare API error logs
              if grep -q "Cloudflare API error" bot.log 2>/dev/null; then
                # Get the error message associated with this status code
                ERROR_LINE=$(grep -A 3 "Cloudflare API response: Status $STATUS_CODE_NUM" bot.log | grep "Cloudflare API error" | tail -1)
                if [ -n "$ERROR_LINE" ]; then
                  ERROR_MSG=$(echo "$ERROR_LINE" | sed -n 's/.*Cloudflare API error [0-9]*: *\(.*\)/\1/p')
                fi
              fi
              
              # If no error message found, set default based on status code
              if [ -z "$ERROR_MSG" ]; then
                case "$STATUS_CODE_NUM" in
                  401)
                    ERROR_MSG="Token authentication failed - token may be invalid"
                    ;;
                  403)
                    ERROR_MSG="Permission denied - token lacks Radar API permission"
                    ;;
                  404)
                    ERROR_MSG="API endpoint not found - check URL"
                    ;;
                  429)
                    ERROR_MSG="Rate limit exceeded"
                    ;;
                  500|502|503|504)
                    ERROR_MSG="Cloudflare API server error"
                    ;;
                  *)
                    ERROR_MSG="HTTP Status $STATUS_CODE_NUM - $STATUS_TEXT"
                    ;;
                esac
              fi
              
              # Try to get response body if available
              if grep -q "Cloudflare API returned non-200 status. Response body:" bot.log 2>/dev/null; then
                RESPONSE_BODY=$(grep "Cloudflare API returned non-200 status. Response body:" bot.log | tail -1 | sed 's/.*Response body: *//' | cut -c1-200)
              fi
            fi
          elif grep -q "Error making HTTP request to Cloudflare" bot.log 2>/dev/null; then
            # Network/connection error
            API_CONNECTED=false
            STATUS_CODE="Connection Failed"
            ERROR_MSG=$(grep "Error making HTTP request to Cloudflare" bot.log | tail -1 | sed 's/.*Error making HTTP request to Cloudflare: *//')
          elif grep -q "Fetching Cloudflare Radar data from:" bot.log 2>/dev/null; then
            # API call was attempted but no response logged yet
            API_CONNECTED=false
            STATUS_CODE="No Response Yet"
            ERROR_MSG="API call initiated but no response logged yet - check logs"
          else
            # No API calls found in logs at all
            API_CONNECTED=false
            STATUS_CODE="Not Attempted Yet"
            ERROR_MSG="No Cloudflare API calls found in logs - bot may not have started fetching data yet"
          fi
          
          # Print summary
          echo ""
          if [ "$TOKEN_RECEIVED" = true ]; then
            echo "‚úÖ Token Status: RECEIVED"
            if [ -n "$AUTH_METHOD" ]; then
              echo "   Authentication: $AUTH_METHOD"
            fi
          else
            echo "‚ùå Token Status: NOT RECEIVED"
            echo "   Check if CLOUDFLARE_TOKEN secret is set in repository settings"
          fi
          
          echo ""
          if [ "$API_CONNECTED" = true ]; then
            echo "‚úÖ Connection Status: CONNECTED to Cloudflare"
            echo "   HTTP Status: $STATUS_CODE"
            if [ "$DATA_AVAILABLE" = true ]; then
              if [ "$DATA_POINTS" -gt 0 ]; then
                echo "‚úÖ Data Status: AVAILABLE ($DATA_POINTS data points received)"
              else
                echo "‚úÖ Data Status: AVAILABLE (data received)"
              fi
              # Show traffic data details if available
              if grep -q "Traffic data processed successfully" bot.log 2>/dev/null; then
                TRAFFIC_LINE=$(grep "Traffic data processed successfully" bot.log | tail -1)
                echo "   $TRAFFIC_LINE"
              fi
            else
              echo "‚ö†Ô∏è  Data Status: API connected but no data received yet"
            fi
          else
            echo "‚ùå Connection Status: NOT CONNECTED to Cloudflare"
            if [ -n "$STATUS_CODE" ]; then
              echo "   HTTP Status: $STATUS_CODE"
            else
              echo "   HTTP Status: (No status code logged yet)"
            fi
            if [ -n "$ERROR_MSG" ]; then
              echo "   Error: $ERROR_MSG"
            else
              echo "   Error: (No error message found in logs)"
            fi
            echo "   Data Status: NOT AVAILABLE (using default 1% connection data)"
          fi
          
          # ALWAYS show diagnostic information section when NOT CONNECTED
          # Debug: Show API_CONNECTED value
          echo ""
          echo "Debug: API_CONNECTED value is '$API_CONNECTED'"
          
          # Use != "true" to catch false, empty, or any other value
          if [ "$API_CONNECTED" != "true" ]; then
            echo ""
            echo "=========================================="
            echo "--- Cloudflare Diagnostic Information ---"
            echo "=========================================="
            
            # Show last API call URL
            if grep -q "Fetching Cloudflare Radar data from:" bot.log 2>/dev/null; then
              API_URL=$(grep "Fetching Cloudflare Radar data from:" bot.log | tail -1 | sed 's/.*Fetching Cloudflare Radar data from: *//')
              echo "Last API Call URL: $API_URL"
            fi
            
            # Show authentication method used
            if grep -q "Using Cloudflare.*authentication" bot.log 2>/dev/null; then
              AUTH_USED=$(grep "Using Cloudflare.*authentication" bot.log | tail -1)
              echo "Authentication Used: $AUTH_USED"
            fi
            
            # Show recent Cloudflare-related log lines (last 10 lines)
            echo ""
            echo "Recent Cloudflare API Logs (last 10 lines):"
            CLOUDFLARE_LOGS=$(grep -i "cloudflare\|radar" bot.log 2>/dev/null | tail -10)
            if [ -n "$CLOUDFLARE_LOGS" ]; then
              echo "$CLOUDFLARE_LOGS" | while read line; do
                echo "  $line"
              done
            else
              echo "  (No Cloudflare logs found in bot.log)"
              echo ""
              echo "  Checking if bot.log exists and has content..."
              if [ -f bot.log ]; then
                LOG_SIZE=$(wc -l < bot.log)
                echo "  bot.log exists with $LOG_SIZE lines"
                echo "  Last 5 lines of bot.log:"
                tail -5 bot.log | while read line; do
                  echo "    $line"
                done
              else
                echo "  bot.log file does not exist"
              fi
            fi
            
            # Show response body if available
            if [ -n "$RESPONSE_BODY" ]; then
              echo ""
              echo "Response Body Preview (first 200 chars):"
              echo "  $RESPONSE_BODY"
            fi
            
            # Show all HTTP status codes encountered
            if grep -q "Cloudflare API response: Status" bot.log 2>/dev/null; then
              echo ""
              echo "All HTTP Status Codes Encountered:"
              grep "Cloudflare API response: Status" bot.log | sed 's/.*Cloudflare API response: Status \([0-9]*\).*/\1/' | sort -u | while read code; do
                COUNT=$(grep "Cloudflare API response: Status $code" bot.log | wc -l)
                echo "  Status $code: $COUNT time(s)"
              done
            else
              echo ""
              echo "No HTTP status codes found in logs (API call may not have completed yet)"
            fi
            
            # Show all Cloudflare API errors
            if grep -q "Cloudflare API error" bot.log 2>/dev/null; then
              echo ""
              echo "All Cloudflare API Errors:"
              grep "Cloudflare API error" bot.log | tail -5 | while read line; do
                echo "  $line"
              done
            else
              echo ""
              echo "No Cloudflare API errors found in logs"
            fi
            
            # Show any network errors
            if grep -q "Error making HTTP request to Cloudflare" bot.log 2>/dev/null; then
              echo ""
              echo "Network Connection Errors:"
              grep "Error making HTTP request to Cloudflare" bot.log | tail -3 | while read line; do
                echo "  $line"
              done
            fi
            
            # Show if API calls are being attempted
            if grep -q "Fetching Cloudflare Radar data from:" bot.log 2>/dev/null; then
              API_CALL_COUNT=$(grep "Fetching Cloudflare Radar data from:" bot.log | wc -l)
              echo ""
              echo "API Calls Attempted: $API_CALL_COUNT time(s)"
              echo "Last API Call:"
              grep "Fetching Cloudflare Radar data from:" bot.log | tail -1 | sed 's/.*Fetching Cloudflare Radar data from: *//' | while read line; do
                echo "  $line"
              done
            else
              echo ""
              echo "‚ö†Ô∏è  No API calls found in logs - bot may not be attempting Cloudflare API calls yet"
              echo ""
              echo "  Possible reasons:"
              echo "  1. Bot is still initializing (PerformInitialCheck may not have run yet)"
              echo "  2. Bot.log file may not have been flushed yet"
              echo "  3. FetchFromCloudflare may not be getting called"
              echo ""
              echo "  Checking bot.log for any Cloudflare-related activity..."
              if [ -f bot.log ]; then
                echo "  Searching for 'Cloudflare' or 'radar' in bot.log:"
                grep -i "cloudflare\|radar" bot.log 2>/dev/null | head -20 || echo "    (No matches found)"
                echo ""
                echo "  Searching for 'Fetching' or 'traffic' in bot.log:"
                grep -i "fetching\|traffic" bot.log 2>/dev/null | head -10 || echo "    (No matches found)"
                echo ""
                echo "  Total lines in bot.log: $(wc -l < bot.log)"
                echo "  Last 10 lines of bot.log:"
                tail -10 bot.log | while read line; do
                  echo "    $line"
                done
              fi
            fi
            
            echo ""
            echo "=========================================="
            echo "--- End Diagnostic Information ---"
            echo "=========================================="
          fi
          
          echo ""
          echo "=========================================="
        fi
        
        echo "=========================================="
        echo ""
        echo "This workflow will stay 'Running' (yellow status) forever."
        echo "To stop the bot: Cancel this workflow in GitHub Actions UI"
        echo "To restart: Cancel workflow, then push a new commit or trigger manually"
        echo ""
        echo "=========================================="
        echo ""
        
        # Calculate restart time (5.5 hours = 330 minutes = 19800 seconds)
        # GitHub Actions free tier has 6-hour limit, restart at 5.5 hours to be safe
        RESTART_SECONDS=19800  # 5.5 hours
        START_TIME=$(date +%s)
        RESTART_TIME=$((START_TIME + RESTART_SECONDS))
        
        echo "‚è∞ Bot will auto-restart at $(date -d @$RESTART_TIME '+%Y-%m-%d %H:%M:%S UTC')"
        echo "   (This is 5.5 hours from now to avoid GitHub Actions 6-hour limit)"
        echo ""
        
        # Infinite loop - keeps workflow alive until restart time
        while true; do
          CURRENT_TIME=$(date +%s)
          TIME_UNTIL_RESTART=$((RESTART_TIME - CURRENT_TIME))
          
          # Check if it's time to restart (within 60 seconds of restart time)
          if [ $TIME_UNTIL_RESTART -le 60 ]; then
            echo ""
            echo "=========================================="
            echo "üîÑ Auto-restarting workflow to avoid 6-hour limit"
            echo "   Current time: $(date '+%Y-%m-%d %H:%M:%S UTC')"
            echo "   Bot has been running for ~5.5 hours"
            echo "=========================================="
            echo ""
            
            # Trigger workflow restart by updating a trigger file
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Ensure we have the latest remote state
            git fetch origin main 2>/dev/null || true
            git pull origin main --rebase 2>/dev/null || true
            
            echo "$(date +%s)" > .trigger
            git add .trigger
            
            # Commit and push with error handling
            if git commit -m "Auto-restart: Workflow restart before 6-hour limit"; then
              echo "‚úÖ Trigger file committed successfully"
              if git push origin main; then
                echo "‚úÖ Trigger file pushed successfully"
              else
                echo "‚ùå Failed to push trigger file. Retrying..."
                sleep 2
                git push origin main || echo "‚ùå Push failed on retry"
              fi
            else
              echo "‚ùå Failed to commit trigger file (may already be committed)"
            fi
            
            # Give a moment for the push to complete
            sleep 5
            
            echo "‚úÖ Trigger file pushed. New workflow will start shortly."
            echo "   This workflow will exit, and the new one will take over."
            exit 0
          fi
          
          # Check if bot is still running
          if ! kill -0 $BOT_PID 2>/dev/null; then
            echo ""
            echo "=========================================="
            echo "‚úó Bot process died at $(date)"
            echo "=========================================="
            echo ""
            echo "Full logs:"
            cat bot.log
            exit 1
          fi
          
          # Show timestamp and status
          HOURS_ELAPSED=$(( (CURRENT_TIME - START_TIME) / 3600 ))
          MINUTES_ELAPSED=$(( ((CURRENT_TIME - START_TIME) % 3600) / 60 ))
          HOURS_UNTIL_RESTART=$((TIME_UNTIL_RESTART / 3600))
          MINUTES_UNTIL_RESTART=$(( (TIME_UNTIL_RESTART % 3600) / 60 ))
          
          echo "[$(date '+%Y-%m-%d %H:%M:%S UTC')] Check #$COUNTER - Bot alive (PID: $BOT_PID) | Running: ${HOURS_ELAPSED}h ${MINUTES_ELAPSED}m | Restart in: ${HOURS_UNTIL_RESTART}h ${MINUTES_UNTIL_RESTART}m"
          
          # Every 10 checks (50 minutes), show recent logs and Cloudflare status
          if [ $((COUNTER % 10)) -eq 0 ]; then
            echo ""
            echo "--- Recent bot activity (last 30 lines) ---"
            tail -30 bot.log | grep -v "^$" || echo "No recent activity"
            echo "--- End of recent activity ---"
            echo ""
            echo "--- Cloudflare Radar API Status ---"
            # Quick status check
            if grep -q "Cloudflare API response: Status 200" bot.log 2>/dev/null && grep -q "Cloudflare API success - received" bot.log 2>/dev/null; then
              echo "‚úÖ CONNECTED - Radar data is AVAILABLE"
              LATEST_SUCCESS=$(grep "Cloudflare API success - received" bot.log | tail -1)
              echo "  Latest: $LATEST_SUCCESS"
            elif grep -q "Cloudflare API response: Status 401\|Cloudflare API response: Status 403" bot.log 2>/dev/null; then
              echo "‚ùå NOT CONNECTED - Authentication failed"
              LATEST_ERROR=$(grep "Cloudflare API response: Status" bot.log | tail -1)
              echo "  $LATEST_ERROR"
            elif grep -q "Cloudflare API response: Status" bot.log 2>/dev/null; then
              LATEST_STATUS=$(grep "Cloudflare API response: Status" bot.log | tail -1)
              echo "‚ö†Ô∏è  Status: $LATEST_STATUS"
            else
              echo "‚è≥ Waiting for Cloudflare API response..."
            fi
            echo "--- End Cloudflare Status ---"
            echo ""
          fi
          
          # Sleep for 5 minutes between checks
          sleep 300
          
          COUNTER=$((COUNTER + 1))
        done
